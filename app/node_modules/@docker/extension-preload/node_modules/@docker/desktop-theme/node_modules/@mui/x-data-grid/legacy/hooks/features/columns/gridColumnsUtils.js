import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _extends from "@babel/runtime/helpers/esm/extends";
import { DEFAULT_GRID_COL_TYPE_KEY, getGridDefaultColumnTypes } from '../../../models';
import { gridColumnsSelector, gridColumnVisibilityModelSelector } from './gridColumnsSelector';
import { clamp } from '../../../utils/utils';
export var computeColumnTypes = function computeColumnTypes() {
  var customColumnTypes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var mergedColumnTypes = _extends({}, getGridDefaultColumnTypes());

  Object.entries(customColumnTypes).forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        colType = _ref2[0],
        colTypeDef = _ref2[1];

    if (mergedColumnTypes[colType]) {
      mergedColumnTypes[colType] = _extends({}, mergedColumnTypes[colType], colTypeDef);
    } else {
      mergedColumnTypes[colType] = _extends({}, mergedColumnTypes[colTypeDef.extendType || DEFAULT_GRID_COL_TYPE_KEY], colTypeDef);
    }
  });
  return mergedColumnTypes;
};
/**
 * Computes width for flex columns.
 * Based on CSS Flexbox specification:
 * https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths
 */

export function computeFlexColumnsWidth(_ref3) {
  var initialFreeSpace = _ref3.initialFreeSpace,
      totalFlexUnits = _ref3.totalFlexUnits,
      flexColumns = _ref3.flexColumns;
  var flexColumnsLookup = {
    all: {},
    frozenFields: [],
    freeze: function freeze(field) {
      var value = flexColumnsLookup.all[field];

      if (value && value.frozen !== true) {
        flexColumnsLookup.all[field].frozen = true;
        flexColumnsLookup.frozenFields.push(field);
      }
    }
  }; // Step 5 of https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths

  function loopOverFlexItems() {
    // 5a: If all the flex items on the line are frozen, free space has been distributed.
    if (flexColumnsLookup.frozenFields.length === flexColumns.length) {
      return;
    }

    var violationsLookup = {
      min: {},
      max: {}
    };
    var remainingFreeSpace = initialFreeSpace;
    var flexUnits = totalFlexUnits;
    var totalViolation = 0; // 5b: Calculate the remaining free space

    flexColumnsLookup.frozenFields.forEach(function (field) {
      remainingFreeSpace -= flexColumnsLookup.all[field].computedWidth;
      flexUnits -= flexColumnsLookup.all[field].flex;
    });

    for (var i = 0; i < flexColumns.length; i += 1) {
      var column = flexColumns[i];

      if (flexColumnsLookup.all[column.field] && flexColumnsLookup.all[column.field].frozen === true) {
        // eslint-disable-next-line no-continue
        continue;
      } // 5c: Distribute remaining free space proportional to the flex factors


      var widthPerFlexUnit = remainingFreeSpace / flexUnits;
      var computedWidth = widthPerFlexUnit * column.flex; // 5d: Fix min/max violations

      if (computedWidth < column.minWidth) {
        totalViolation += column.minWidth - computedWidth;
        computedWidth = column.minWidth;
        violationsLookup.min[column.field] = true;
      } else if (computedWidth > column.maxWidth) {
        totalViolation += column.maxWidth - computedWidth;
        computedWidth = column.maxWidth;
        violationsLookup.max[column.field] = true;
      }

      flexColumnsLookup.all[column.field] = {
        frozen: false,
        computedWidth: computedWidth,
        flex: column.flex
      };
    } // 5e: Freeze over-flexed items


    if (totalViolation < 0) {
      // Freeze all the items with max violations
      Object.keys(violationsLookup.max).forEach(function (field) {
        flexColumnsLookup.freeze(field);
      });
    } else if (totalViolation > 0) {
      // Freeze all the items with min violations
      Object.keys(violationsLookup.min).forEach(function (field) {
        flexColumnsLookup.freeze(field);
      });
    } else {
      // Freeze all items
      flexColumns.forEach(function (_ref4) {
        var field = _ref4.field;
        flexColumnsLookup.freeze(field);
      });
    } // 5f: Return to the start of this loop


    loopOverFlexItems();
  }

  loopOverFlexItems();
  return flexColumnsLookup.all;
}
/**
 * Compute the `computedWidth` (ie: the width the column should have during rendering) based on the `width` / `flex` / `minWidth` / `maxWidth` properties of `GridColDef`.
 * The columns already have been merged with there `type` default values for `minWidth`, `maxWidth` and `width`, thus the `!` for those properties below.
 * TODO: Unit test this function in depth and only keep basic cases for the whole grid testing.
 * TODO: Improve the `GridColDef` typing to reflect the fact that `minWidth` / `maxWidth` and `width` can't be null after the merge with the `type` default values.
 */

export var hydrateColumnsWidth = function hydrateColumnsWidth(rawState, viewportInnerWidth) {
  var columnsLookup = {};
  var totalFlexUnits = 0;
  var widthAllocatedBeforeFlex = 0;
  var flexColumns = []; // For the non-flex columns, compute their width
  // For the flex columns, compute there minimum width and how much width must be allocated during the flex allocation

  rawState.all.forEach(function (columnField) {
    var newColumn = _extends({}, rawState.lookup[columnField]);

    if (rawState.columnVisibilityModel[columnField] === false) {
      newColumn.computedWidth = 0;
    } else {
      var computedWidth;

      if (newColumn.flex && newColumn.flex > 0) {
        totalFlexUnits += newColumn.flex;
        computedWidth = 0;
        flexColumns.push(newColumn);
      } else {
        computedWidth = clamp(newColumn.width, newColumn.minWidth, newColumn.maxWidth);
      }

      widthAllocatedBeforeFlex += computedWidth;
      newColumn.computedWidth = computedWidth;
    }

    columnsLookup[columnField] = newColumn;
  });
  var initialFreeSpace = Math.max(viewportInnerWidth - widthAllocatedBeforeFlex, 0); // Allocate the remaining space to the flex columns

  if (totalFlexUnits > 0 && viewportInnerWidth > 0) {
    var computedColumnWidths = computeFlexColumnsWidth({
      initialFreeSpace: initialFreeSpace,
      totalFlexUnits: totalFlexUnits,
      flexColumns: flexColumns
    });
    Object.keys(computedColumnWidths).forEach(function (field) {
      columnsLookup[field].computedWidth = computedColumnWidths[field].computedWidth;
    });
  }

  return _extends({}, rawState, {
    lookup: columnsLookup
  });
};
var columnTypeWarnedOnce = false;
/**
 * @deprecated Should have been internal only, you can inline the logic.
 */

export var getGridColDef = function getGridColDef(columnTypes, type) {
  if (!type) {
    return columnTypes[DEFAULT_GRID_COL_TYPE_KEY];
  }

  if (process.env.NODE_ENV !== 'production') {
    if (!columnTypeWarnedOnce && !columnTypes[type]) {
      console.warn(["MUI: The column type \"".concat(type, "\" you are using is not supported."), "Column type \"string\" is being used instead."].join('\n'));
      columnTypeWarnedOnce = true;
    }
  }

  if (!columnTypes[type]) {
    return columnTypes[DEFAULT_GRID_COL_TYPE_KEY];
  }

  return columnTypes[type];
};
export var createColumnsState = function createColumnsState(_ref5) {
  var _apiRef$current$getRo, _apiRef$current$getRo2, _apiRef$current, _apiRef$current$getRo3;

  var apiRef = _ref5.apiRef,
      columnsToUpsert = _ref5.columnsToUpsert,
      columnsTypes = _ref5.columnsTypes,
      _ref5$currentColumnVi = _ref5.currentColumnVisibilityModel,
      currentColumnVisibilityModel = _ref5$currentColumnVi === void 0 ? gridColumnVisibilityModelSelector(apiRef) : _ref5$currentColumnVi,
      shouldRegenColumnVisibilityModelFromColumns = _ref5.shouldRegenColumnVisibilityModelFromColumns,
      reset = _ref5.reset;
  var columnsStateWithoutColumnVisibilityModel;

  if (reset) {
    columnsStateWithoutColumnVisibilityModel = {
      all: [],
      lookup: {}
    };
  } else {
    var currentState = gridColumnsSelector(apiRef.current.state);
    columnsStateWithoutColumnVisibilityModel = {
      all: _toConsumableArray(currentState.all),
      lookup: _extends({}, currentState.lookup)
    };
  }

  var columnsToUpsertLookup = {};
  columnsToUpsert.forEach(function (newColumn) {
    columnsToUpsertLookup[newColumn.field] = true;

    if (columnsStateWithoutColumnVisibilityModel.lookup[newColumn.field] == null) {
      // New Column
      columnsStateWithoutColumnVisibilityModel.lookup[newColumn.field] = _extends({}, getGridColDef(columnsTypes, newColumn.type), newColumn);
      columnsStateWithoutColumnVisibilityModel.all.push(newColumn.field);
    } else {
      columnsStateWithoutColumnVisibilityModel.lookup[newColumn.field] = _extends({}, columnsStateWithoutColumnVisibilityModel.lookup[newColumn.field], newColumn);
    }
  });

  var columnsLookupBeforePreProcessing = _extends({}, columnsStateWithoutColumnVisibilityModel.lookup);

  var columnsStateWithPreProcessing = apiRef.current.unstable_applyPreProcessors('hydrateColumns', columnsStateWithoutColumnVisibilityModel); // TODO v6: remove the sync between the columns `hide` option and the model.

  var columnVisibilityModel = {};

  if (shouldRegenColumnVisibilityModelFromColumns) {
    if (reset) {
      columnsStateWithPreProcessing.all.forEach(function (field) {
        columnVisibilityModel[field] = !columnsStateWithoutColumnVisibilityModel.lookup[field].hide;
      });
    } else {
      var newColumnVisibilityModel = _extends({}, currentColumnVisibilityModel);

      var hasModelChanged = false;
      columnsStateWithPreProcessing.all.forEach(function (field) {
        var _currentColumnVisibil;

        // If neither the `columnsToUpsert` nor the pre-processors updated the column,
        // Then we don't want to update the visibility status of the column in the model.
        if (!columnsToUpsertLookup[field] && columnsLookupBeforePreProcessing[field] === columnsStateWithPreProcessing.lookup[field]) {
          return;
        }

        var isVisibleBefore = (_currentColumnVisibil = currentColumnVisibilityModel[field]) != null ? _currentColumnVisibil : true;
        var isVisibleAfter = !columnsStateWithPreProcessing.lookup[field].hide;

        if (isVisibleAfter !== isVisibleBefore) {
          hasModelChanged = true;
          newColumnVisibilityModel[field] = isVisibleAfter;
        }
      });

      if (hasModelChanged) {
        columnVisibilityModel = newColumnVisibilityModel;
      } else {
        columnVisibilityModel = currentColumnVisibilityModel;
      }
    }
  } else {
    columnVisibilityModel = currentColumnVisibilityModel;
  }

  var columnsState = _extends({}, columnsStateWithPreProcessing, {
    columnVisibilityModel: columnVisibilityModel
  });

  return hydrateColumnsWidth(columnsState, (_apiRef$current$getRo = (_apiRef$current$getRo2 = (_apiRef$current = apiRef.current).getRootDimensions) == null ? void 0 : (_apiRef$current$getRo3 = _apiRef$current$getRo2.call(_apiRef$current)) == null ? void 0 : _apiRef$current$getRo3.viewportInnerSize.width) != null ? _apiRef$current$getRo : 0);
};
export var setColumnsState = function setColumnsState(columnsState) {
  return function (state) {
    return _extends({}, state, {
      columns: columnsState
    });
  };
};